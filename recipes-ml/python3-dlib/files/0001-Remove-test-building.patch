From 15c4c704d6bb12e2555db71eb343c4ee6afbaaf6 Mon Sep 17 00:00:00 2001
From: Illia Vysochyn <bitfun6@gmail.com>
Date: Tue, 18 Oct 2022 15:39:32 +0200
Subject: [PATCH] Remove test building

---
 dlib/CMakeLists.txt | 113 +++++++++++++-------------------------------
 1 file changed, 32 insertions(+), 81 deletions(-)

diff --git a/dlib/CMakeLists.txt b/dlib/CMakeLists.txt
index 9f3001d4..55556811 100644
--- a/dlib/CMakeLists.txt
+++ b/dlib/CMakeLists.txt
@@ -49,7 +49,7 @@ endif()
 include(cmake_utils/release_build_by_default)
 include(cmake_utils/use_cpp_11.cmake)
 
-# Set DLIB_VERSION in the including CMake file so they can use it to do whatever they want. 
+# Set DLIB_VERSION in the including CMake file so they can use it to do whatever they want.
 get_directory_property(has_parent PARENT_DIRECTORY)
 if(has_parent)
    set(DLIB_VERSION ${VERSION} PARENT_SCOPE)
@@ -73,7 +73,7 @@ endif()
 
 if (DLIB_IN_PROJECT_BUILD)
 
-   # Check if we are being built as part of a pybind11 module. 
+   # Check if we are being built as part of a pybind11 module.
    if (COMMAND pybind11_add_module)
       set(CMAKE_POSITION_INDEPENDENT_CODE True)
       if (CMAKE_COMPILER_IS_GNUCXX)
@@ -109,7 +109,7 @@ if (DLIB_IN_PROJECT_BUILD)
 
 elseif(BUILD_SHARED_LIBS)
    if (MSVC)
-      message(FATAL_ERROR "Building dlib as a standalone dll is not supported when using Visual Studio.  You are highly encouraged to use static linking instead.  See https://github.com/davisking/dlib/issues/1483 for a discussion.") 
+      message(FATAL_ERROR "Building dlib as a standalone dll is not supported when using Visual Studio.  You are highly encouraged to use static linking instead.  See https://github.com/davisking/dlib/issues/1483 for a discussion.")
    endif()
 endif()
 
@@ -157,14 +157,14 @@ endif()
 # because it avoids getting warnings/errors about cmake policy CMP0002.  This
 # happens when a project tries to call add_subdirectory() on dlib more than
 # once.  This most often happens when the top level of a project depends on two
-# or more other things which both depend on dlib. 
+# or more other things which both depend on dlib.
 if (NOT TARGET dlib)
 
-   set (DLIB_ISO_CPP_ONLY_STR 
+   set (DLIB_ISO_CPP_ONLY_STR
       "Enable this if you don't want to compile any non-ISO C++ code (i.e. you don't use any of the API Wrappers)" )
-   set (DLIB_NO_GUI_SUPPORT_STR 
+   set (DLIB_NO_GUI_SUPPORT_STR
       "Enable this if you don't want to compile any of the dlib GUI code" )
-   set (DLIB_ENABLE_STACK_TRACE_STR 
+   set (DLIB_ENABLE_STACK_TRACE_STR
       "Enable this if you want to turn on the DLIB_STACK_TRACE macros" )
    set (DLIB_USE_BLAS_STR
       "Disable this if you don't want to use a BLAS library" )
@@ -209,14 +209,14 @@ if (NOT TARGET dlib)
       # Set these variables so they are set in the config.h.in file when dlib
       # is installed.
       set (DLIB_DISABLE_ASSERTS false)
-      set (ENABLE_ASSERTS true) 
+      set (ENABLE_ASSERTS true)
       enable_preprocessor_switch(ENABLE_ASSERTS)
       disable_preprocessor_switch(DLIB_DISABLE_ASSERTS)
    else()
       # Set these variables so they are set in the config.h.in file when dlib
       # is installed.
       set (DLIB_DISABLE_ASSERTS true)
-      set (ENABLE_ASSERTS false) 
+      set (ENABLE_ASSERTS false)
       disable_preprocessor_switch(ENABLE_ASSERTS)
       # Never force the asserts off when doing an in project build.  The only
       # time this matters is when using visual studio.  The visual studio IDE
@@ -228,7 +228,7 @@ if (NOT TARGET dlib)
       # we make a point to not do that kind of severe disabling when in a
       # project build.  It should also be pointed out that DLIB_DISABLE_ASSERTS
       # is only needed when building and installing dlib as a separately
-      # installed library.  It doesn't matter when doing an in project build. 
+      # installed library.  It doesn't matter when doing an in project build.
       if (NOT DLIB_IN_PROJECT_BUILD)
          enable_preprocessor_switch(DLIB_DISABLE_ASSERTS)
       endif()
@@ -263,8 +263,8 @@ if (NOT TARGET dlib)
    toggle_preprocessor_switch(DLIB_USE_BLAS)
    toggle_preprocessor_switch(DLIB_USE_LAPACK)
    toggle_preprocessor_switch(DLIB_USE_CUDA)
-   toggle_preprocessor_switch(DLIB_PNG_SUPPORT) 
-   toggle_preprocessor_switch(DLIB_GIF_SUPPORT) 
+   toggle_preprocessor_switch(DLIB_PNG_SUPPORT)
+   toggle_preprocessor_switch(DLIB_GIF_SUPPORT)
    #toggle_preprocessor_switch(DLIB_USE_FFTW)
    toggle_preprocessor_switch(DLIB_USE_MKL_FFT)
 
@@ -337,7 +337,7 @@ if (NOT TARGET dlib)
          set(dlib_needed_libraries ${dlib_needed_libraries} ${CMAKE_THREAD_LIBS_INIT})
       endif()
 
-      # we want to link to the right stuff depending on our platform.  
+      # we want to link to the right stuff depending on our platform.
       if (WIN32 AND NOT CYGWIN) ###############################################################################
          if (DLIB_NO_GUI_SUPPORT)
             set (dlib_needed_libraries ws2_32 winmm)
@@ -364,7 +364,7 @@ if (NOT TARGET dlib)
                # Xlocale.h rather than Xlib.h because it avoids finding a partial
                # copy of the X11 headers on systems with anaconda installed.
                find_path(xlib_path Xlocale.h
-                  PATHS 
+                  PATHS
                   /Developer/SDKs/MacOSX10.4u.sdk/usr/X11R6/include
                   /opt/local/include
                   PATH_SUFFIXES X11
@@ -628,7 +628,7 @@ if (NOT TARGET dlib)
          find_package(CUDA 7.5)
 
          if (CUDA_VERSION VERSION_GREATER 9.1 AND CMAKE_VERSION VERSION_LESS 3.12.2)
-            # This bit of weirdness is to work around a bug in cmake 
+            # This bit of weirdness is to work around a bug in cmake
             list(REMOVE_ITEM CUDA_CUBLAS_LIBRARIES "CUDA_cublas_device_LIBRARY-NOTFOUND")
          endif()
 
@@ -656,7 +656,7 @@ if (NOT TARGET dlib)
                # to nvcc.
                string(REGEX MATCHALL "-D[^ ]*" FLAGS_FOR_NVCC "${CMAKE_CXX_FLAGS}")
 
-               # Check if we are being built as part of a pybind11 module. 
+               # Check if we are being built as part of a pybind11 module.
                if (COMMAND pybind11_add_module)
                   # Don't export unnecessary symbols.
                   list(APPEND FLAGS_FOR_NVCC "-Xcompiler=-fvisibility=hidden")
@@ -688,55 +688,6 @@ if (NOT TARGET dlib)
 
             include(cmake_utils/test_for_cudnn/find_cudnn.txt)
 
-            if (cudnn AND cudnn_include AND NOT DEFINED cuda_test_compile_worked AND NOT DEFINED cudnn_test_compile_worked)
-               # make sure cuda is really working by doing a test compile
-               message(STATUS "Building a CUDA test project to see if your compiler is compatible with CUDA...")
-
-               set(CUDA_TEST_CMAKE_FLAGS 
-                  "-DCMAKE_PREFIX_PATH=${CMAKE_PREFIX_PATH}"
-                  "-DCMAKE_INCLUDE_PATH=${CMAKE_INCLUDE_PATH}"
-                  "-DCMAKE_LIBRARY_PATH=${CMAKE_LIBRARY_PATH}")
-
-               if (NOT MSVC) # see https://github.com/davisking/dlib/issues/363
-                  list(APPEND CUDA_TEST_CMAKE_FLAGS "-DCUDA_HOST_COMPILER=${CUDA_HOST_COMPILER}")
-               endif()
-
-               try_compile(cuda_test_compile_worked 
-                  ${PROJECT_BINARY_DIR}/cuda_test_build 
-                  ${PROJECT_SOURCE_DIR}/cmake_utils/test_for_cuda cuda_test
-                  CMAKE_FLAGS ${CUDA_TEST_CMAKE_FLAGS}
-                  OUTPUT_VARIABLE try_compile_output_message
-                  )
-               if (NOT cuda_test_compile_worked)
-                  string(REPLACE "\n" "\n   ***   " try_compile_output_message "${try_compile_output_message}")
-                  message(STATUS "*****************************************************************************************************************")
-                  message(STATUS "*** CUDA was found but your compiler failed to compile a simple CUDA program so dlib isn't going to use CUDA. ")
-                  message(STATUS "*** The output of the failed CUDA test compile is shown below: ")
-                  message(STATUS "*** ")
-                  message(STATUS "***   ${try_compile_output_message}")
-                  message(STATUS "*****************************************************************************************************************")
-               else()
-                  message(STATUS "Building a cuDNN test project to check if you have the right version of cuDNN installed...")
-                  try_compile(cudnn_test_compile_worked 
-                     ${PROJECT_BINARY_DIR}/cudnn_test_build 
-                     ${PROJECT_SOURCE_DIR}/cmake_utils/test_for_cudnn cudnn_test
-                     CMAKE_FLAGS ${CUDA_TEST_CMAKE_FLAGS}
-                     OUTPUT_VARIABLE try_compile_output_message
-                     )
-                  if (NOT cudnn_test_compile_worked)
-                     string(REPLACE "\n" "\n   ***   " try_compile_output_message "${try_compile_output_message}")
-                     message(STATUS "*****************************************************************************************************")
-                     message(STATUS "*** Found cuDNN, but we failed to compile the dlib/cmake_utils/test_for_cudnn project. ")
-                     message(STATUS "*** You either have an unsupported version of cuDNN or something is wrong with your cudDNN install.")
-                     message(STATUS "*** Since a functional cuDNN is not found DLIB WILL NOT USE CUDA. ")
-                     message(STATUS "*** The output of the failed test_for_cudnn build is: ")
-                     message(STATUS "*** ")
-                     message(STATUS "***   ${try_compile_output_message}")
-                     message(STATUS "*****************************************************************************************************")
-                  endif()
-               endif()
-            endif()
-
             # Find where cuSOLVER is since the FindCUDA cmake package doesn't
             # bother to look for it in older versions of cmake.
             if (NOT CUDA_cusolver_LIBRARY)
@@ -748,7 +699,7 @@ if (NOT TARGET dlib)
                # look in the cuda install folder for it.  New versions of cmake
                # do this correctly, but older versions need help.
                if (NOT CUDA_cusolver_LIBRARY)
-                  find_library(CUDA_cusolver_LIBRARY cusolver HINTS 
+                  find_library(CUDA_cusolver_LIBRARY cusolver HINTS
                      /usr/local/cuda/lib64/
                      )
                endif()
@@ -768,7 +719,7 @@ if (NOT TARGET dlib)
             if (CUDA_VERSION VERSION_LESS "9.1" AND NOT openmp_libraries AND NOT MSVC AND NOT XCODE AND NOT APPLE)
                find_package(OpenMP)
                if (OPENMP_FOUND)
-                  set(openmp_libraries ${OpenMP_CXX_FLAGS}) 
+                  set(openmp_libraries ${OpenMP_CXX_FLAGS})
                else()
                   message(STATUS "*** Didn't find OpenMP, which is required to use CUDA. ***")
                   set(CUDA_FOUND 0)
@@ -776,9 +727,9 @@ if (NOT TARGET dlib)
             endif()
          endif()
 
-         if (CUDA_FOUND AND cudnn AND (NOT USING_OLD_VISUAL_STUDIO_COMPILER) AND cuda_test_compile_worked AND cudnn_test_compile_worked AND cudnn_include)
-            set(source_files ${source_files} 
-               cuda/cuda_dlib.cu 
+         if (CUDA_FOUND AND cudnn AND (NOT USING_OLD_VISUAL_STUDIO_COMPILER) AND cudnn_include)
+            set(source_files ${source_files}
+               cuda/cuda_dlib.cu
                cuda/cudnn_dlibapi.cpp
                cuda/cublas_dlibapi.cpp
                cuda/cusolver_dlibapi.cu
@@ -786,8 +737,8 @@ if (NOT TARGET dlib)
                cuda/cuda_data_ptr.cpp
                cuda/gpu_data.cpp
                )
-            set(dlib_needed_libraries ${dlib_needed_libraries} 
-               ${CUDA_CUBLAS_LIBRARIES} 
+            set(dlib_needed_libraries ${dlib_needed_libraries}
+               ${CUDA_CUBLAS_LIBRARIES}
                ${cudnn}
                ${CUDA_curand_LIBRARY}
                ${CUDA_cusolver_LIBRARY}
@@ -878,7 +829,7 @@ if (NOT TARGET dlib)
       # Do this so that dlib/config.h can record the version of dlib it's configured with
       # and ultimately issue a linker error to people who try to use a binary dlib that is
       # the wrong version.
-      set(DLIB_CHECK_FOR_VERSION_MISMATCH 
+      set(DLIB_CHECK_FOR_VERSION_MISMATCH
          DLIB_VERSION_MISMATCH_CHECK__EXPECTED_VERSION_${CPACK_PACKAGE_VERSION_MAJOR}_${CPACK_PACKAGE_VERSION_MINOR}_${CPACK_PACKAGE_VERSION_PATCH})
       target_compile_options(dlib PRIVATE "-DDLIB_CHECK_FOR_VERSION_MISMATCH=${DLIB_CHECK_FOR_VERSION_MISMATCH}")
    endif()
@@ -886,7 +837,7 @@ if (NOT TARGET dlib)
 
    # Allow the unit tests to ask us to compile the all/source.cpp file just to make sure it compiles.
    if (DLIB_TEST_COMPILE_ALL_SOURCE_CPP)
-      add_library(dlib_all_source_cpp STATIC all/source.cpp) 
+      add_library(dlib_all_source_cpp STATIC all/source.cpp)
       target_link_libraries(dlib_all_source_cpp dlib)
       target_compile_options(dlib_all_source_cpp PUBLIC ${active_preprocessor_switches})
       enable_cpp11_for_target(dlib_all_source_cpp)
@@ -911,14 +862,14 @@ if (NOT TARGET dlib)
       set_target_properties(dlib PROPERTIES
          VERSION ${VERSION})
       install(TARGETS dlib
-         EXPORT dlib 
+         EXPORT dlib
          RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR} # Windows considers .dll to be runtime artifacts
          LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
          ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR})
 
       install(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/ DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/dlib
-         FILES_MATCHING 
-            PATTERN "*.h" 
+         FILES_MATCHING
+            PATTERN "*.h"
             PATTERN "*.cmake"
             PATTERN "*_tutorial.txt"
             PATTERN "cassert"
@@ -957,9 +908,9 @@ if (NOT TARGET dlib)
          COMPATIBILITY AnyNewerVersion
          )
 
-      install(FILES 
-         "${CMAKE_CURRENT_BINARY_DIR}/config/dlibConfig.cmake" 
-         "${CMAKE_CURRENT_BINARY_DIR}/config/dlibConfigVersion.cmake" 
+      install(FILES
+         "${CMAKE_CURRENT_BINARY_DIR}/config/dlibConfig.cmake"
+         "${CMAKE_CURRENT_BINARY_DIR}/config/dlibConfigVersion.cmake"
          DESTINATION ${ConfigPackageLocation})
 
       ## dlib-1.pc generation and installation
@@ -991,7 +942,7 @@ if (MSVC)
    set_target_properties(dlib PROPERTIES RELWITHDEBINFO_POSTFIX "${VERSION}_relwithdebinfo_${numbits}bit_msvc${MSVC_VERSION}")
 endif()
 
-# Check if we are being built as part of a pybind11 module. 
+# Check if we are being built as part of a pybind11 module.
 if (COMMAND pybind11_add_module)
    # Don't export unnecessary symbols.
    set_target_properties(dlib PROPERTIES CXX_VISIBILITY_PRESET "hidden")
-- 
2.38.0

